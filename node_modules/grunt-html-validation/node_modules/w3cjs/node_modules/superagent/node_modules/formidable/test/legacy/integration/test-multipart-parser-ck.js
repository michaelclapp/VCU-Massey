var common=require("../common"),CHUNK_LENGTH=10,multipartParser=require(common.lib+"/multipart_parser"),MultipartParser=multipartParser.MultipartParser,parser=new MultipartParser,fixtures=require(TEST_FIXTURES+"/multipart"),Buffer=require("buffer").Buffer;Object.keys(fixtures).forEach(function(e){var t=fixtures[e],n=new Buffer(Buffer.byteLength(t.raw,"binary")),r=0,i,s,o=[],u=null,a,f,l="";parser.initWithBoundary(t.boundary);parser.onPartBegin=function(){u={headers:{},data:""};o.push(u);a="";f=""};parser.onHeaderField=function(e,t,n){a+=e.toString("ascii",t,n)};parser.onHeaderValue=function(e,t,n){f+=e.toString("ascii",t,n)};parser.onHeaderEnd=function(){u.headers[a]=f;a="";f=""};parser.onPartData=function(e,t,n){var r=e.toString("ascii",t,n);u.data+=e.slice(t,n)};parser.onEnd=function(){l=!0};n.write(t.raw,"binary",0);while(r<n.length){r+CHUNK_LENGTH<n.length?i=n.slice(r,r+CHUNK_LENGTH):i=n.slice(r,n.length);r+=CHUNK_LENGTH;s=parser.write(i);if(s!=i.length){if(t.expectError)return;puts("-- ERROR --");p(i.toString("ascii"));throw new Error(i.length+" bytes written, but only "+s+" bytes parsed!")}}if(t.expectError)throw new Error("expected parse error did not happen");assert.ok(l);assert.deepEqual(o,t.parts)});