/*
 * ctf.js
 *
 * Understand and parse all of the different JSON formats of CTF data and
 * translate that into a series of node-ctype friendly pieces. The reason for
 * the abstraction is to handle different changes in the file format.
 *
 * We have to be careful here that we don't end up using a name that is already
 * a built in type.
 */function ctfParseInteger(e,t){var n,r,i,s;n=e.name;if(!("signed"in e.integer))throw new Error("Malformed CTF JSON: integer missing signed value");if(!("length"in e.integer))throw new Error("Malformed CTF JSON: integer missing length value");r=e.integer.signed;i=e.integer.length;s=null;r&&i==1?s="int8_t":i==1?s="uint8_t":r&&i==2?s="int16_t":i==2?s="uint16_t":r&&i==4?s="int32_t":i==4?s="uint32_t":r&&i==8?s="int64_t":i==8&&(s="uint64_t");if(s===null)throw new Error("Malformed CTF JSON: integer has unsupported length and sign - "+i+"/"+r);if(n==s)return;if(n=="char"){ASSERT(s=="int8_t");return}t.typedef(n,s)}function ctfParseFloat(e,t){var n,r;n=e.name;if(!("length"in e["float"]))throw new Error("Malformed CTF JSON: float missing length value");r=e["float"].length;if(r!=4&&r!=8)throw new Error("Malformed CTF JSON: float has invalid length value");if(r==4){if(n=="float")return;t.typedef(n,"float")}else if(r==8){if(n=="double")return;t.typedef(n,"double")}}function ctfParseTypedef(e,t){var n,r,i;n=e.name;if(typeof e["typedef"]!="string")throw new Error("Malformed CTF JSON: typedef value in not a string");r=e.typedef;for(i=0;i<ctf_deftypes.length;i++)if(n==ctf_deftypes[i])return;t.typedef(n,r)}function ctfParseStruct(e,t){var n,r,i,s,o,u,a;u=[];if(!Array.isArray(e.struct))throw new Error("Malformed CTF JSON: struct value is not an array");for(i=0;i<e.struct.length;i++){s=e.struct[i];if(!("name"in s))throw new Error("Malformed CTF JSON: struct member missing name");if(!("type"in s))throw new Error("Malformed CTF JSON: struct member missing type");if(typeof s["name"]!="string")throw new Error("Malformed CTF JSON: struct member name isn't a string");if(typeof s["type"]!="string")throw new Error("Malformed CTF JSON: struct member type isn't a string");n=s.name;r=s.type;o=r.indexOf(" [");o!=-1&&(r=r.substring(0,o)+r.substring(o+1,r.length));a={};a[n]={type:r};u.push(a)}n=e.name;t.typedef(n,u)}function ctfParseEntry(e,t){var n,r;if(!("name"in e))throw new Error('Malformed CTF JSON: entry missing "name" section');for(n=0;n<ctf_entries.length;n++)ctf_entries[n]in e&&r++;if(r===0)throw new Error("Malformed CTF JSON: found no entries");if(r>=2)throw new Error("Malformed CTF JSON: found more than one entry");if("integer"in e){ctfParseInteger(e,t);return}if("float"in e){ctfParseFloat(e,t);return}if("typedef"in e){ctfParseTypedef(e,t);return}if("struct"in e){ctfParseStruct(e,t);return}ASSERT(!1,"shouldn't reach here")}function ctfParseJson(e,t){var n,r;ASSERT(e);ASSERT(t);if(!("metadata"in e))throw new Error("Invalid CTF JSON: missing metadata section");if(!("ctf2json_version"in e.metadata))throw new Error("Invalid CTF JSON: missing ctf2json_version");n=e.metadata.ctf2json_version;for(r=0;r<ctf_versions.length;r++)if(ctf_versions[r]==n)break;if(r==ctf_versions.length)throw new Error("Unsuported ctf2json_version: "+n);if(!("data"in e))throw new Error("Invalid CTF JSON: missing data section");if(!Array.isArray(e.data))throw new Error("Malformed CTF JSON: data section is not an array");for(r=0;r<e.data.length;r++)ctfParseEntry(e.data[r],t)}var mod_assert=require("assert"),ASSERT=mod_assert.ok,ctf_versions=["1.0"],ctf_entries=["integer","float","typedef","struct"],ctf_deftypes=["int8_t","uint8_t","int16_t","uint16_t","int32_t","uint32_t","float","double"];exports.ctfParseJson=ctfParseJson;