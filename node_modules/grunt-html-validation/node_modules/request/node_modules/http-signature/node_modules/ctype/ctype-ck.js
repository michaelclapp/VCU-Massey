/*
 * rm - Feb 2011
 * ctype.js
 *
 * This module provides a simple abstraction towards reading and writing
 * different types of binary data. It is designed to use ctio.js and provide a
 * richer and more expressive API on top of it.
 *
 * By default we support the following as built in basic types:
 *	int8_t
 *	int16_t
 *	int32_t
 *	uint8_t
 *	uint16_t
 *	uint32_t
 *	uint64_t
 *	float
 *	double
 *	char
 *	char[]
 *
 * Each type is returned as a Number, with the exception of char and char[]
 * which are returned as Node Buffers. A char is considered a uint8_t.
 *
 * Requests to read and write data are specified as an array of JSON objects.
 * This is also the same way that one declares structs. Even if just a single
 * value is requested, it must be done as a struct. The array order determines
 * the order that we try and read values. Each entry has the following format
 * with values marked with a * being optional.
 *
 * { key: { type: /type/, value*: /value/, offset*: /offset/ }
 *
 * If offset is defined, we lseek(offset, SEEK_SET) before reading the next
 * value. Value is defined when we're writing out data, otherwise it's ignored.
 *
 */function ctReadUint8(e,t,n){var r=mod_ctio.ruint8(t,e,n);return{value:r,size:1}}function ctReadUint16(e,t,n){var r=mod_ctio.ruint16(t,e,n);return{value:r,size:2}}function ctReadUint32(e,t,n){var r=mod_ctio.ruint32(t,e,n);return{value:r,size:4}}function ctReadUint64(e,t,n){var r=mod_ctio.ruint64(t,e,n);return{value:r,size:8}}function ctReadSint8(e,t,n){var r=mod_ctio.rsint8(t,e,n);return{value:r,size:1}}function ctReadSint16(e,t,n){var r=mod_ctio.rsint16(t,e,n);return{value:r,size:2}}function ctReadSint32(e,t,n){var r=mod_ctio.rsint32(t,e,n);return{value:r,size:4}}function ctReadSint64(e,t,n){var r=mod_ctio.rsint64(t,e,n);return{value:r,size:8}}function ctReadFloat(e,t,n){var r=mod_ctio.rfloat(t,e,n);return{value:r,size:4}}function ctReadDouble(e,t,n){var r=mod_ctio.rdouble(t,e,n);return{value:r,size:8}}function ctReadChar(e,t,n){var r=new Buffer(1);r[0]=mod_ctio.ruint8(t,e,n);return{value:r,size:1}}function ctReadCharArray(e,t,n,r){var i,s=new Buffer(e);for(i=0;i<e;i++)s[i]=mod_ctio.ruint8(n,t,r+i);return{value:s,size:e}}function ctWriteUint8(e,t,n,r){mod_ctio.wuint8(e,t,n,r);return 1}function ctWriteUint16(e,t,n,r){mod_ctio.wuint16(e,t,n,r);return 2}function ctWriteUint32(e,t,n,r){mod_ctio.wuint32(e,t,n,r);return 4}function ctWriteUint64(e,t,n,r){mod_ctio.wuint64(e,t,n,r);return 8}function ctWriteSint8(e,t,n,r){mod_ctio.wsint8(e,t,n,r);return 1}function ctWriteSint16(e,t,n,r){mod_ctio.wsint16(e,t,n,r);return 2}function ctWriteSint32(e,t,n,r){mod_ctio.wsint32(e,t,n,r);return 4}function ctWriteSint64(e,t,n,r){mod_ctio.wsint64(e,t,n,r);return 8}function ctWriteFloat(e,t,n,r){mod_ctio.wfloat(e,t,n,r);return 4}function ctWriteDouble(e,t,n,r){mod_ctio.wdouble(e,t,n,r);return 8}function ctWriteChar(e,t,n,r){if(e instanceof Buffer){mod_ctio.ruint8(e[0],t,n,r);return 1}throw new Error("Input must be a buffer")}function ctWriteCharArray(e,t,n,r,i){var s;if(e instanceof Buffer){if(e.length>t)throw new Error("value length greater than array length");for(s=0;s<e.length&&s<t;s++)mod_ctio.wuint8(e[s],n,r,i+s);for(;s<t;s++)mod_ctio.wuint8(0,n,i+s);return t}throw new Error("Input must be a buffer")}function ctGetBasicTypes(){var e={},t;for(t in deftypes)e[t]=deftypes[t];return e}function ctParseType(e){var t,n,r,i;if(typeof e!="string")throw new Error("type must be a Javascript string");n=e.lastIndexOf("]");if(n==-1){if(e.lastIndexOf("[")!=-1)throw new Error("found invalid type with '[' but no corresponding ']'");return{type:e}}t=e.lastIndexOf("[");if(t==-1)throw new Error("found invalid type with ']' but no corresponding '['");if(t>=n)throw new Error("malformed type, ']' appears before '['");r=e.substring(0,t);i=e.substring(t+1,n);return{type:r,len:i}}function ctCheckReq(e,t,n){var r,i,s,o,u,a={};if(!(e instanceof Array))throw new Error("definition is not an array");if(e.length===0)throw new Error("definition must have at least one element");for(r=0;r<e.length;r++){s=e[r];if(!(s instanceof Object))throw new Error("definition must be an array ofobjects");o=Object.keys(s);if(o.length!=1)throw new Error("definition entry must only have one key");if(o[0]in a)throw new Error("Specified name already specified: "+o[0]);if(!("type"in s[o[0]]))throw new Error("missing required type definition");u=ctParseType(s[o[0]].type);while(u.len!==undefined){if(!(!isNaN(parseInt(u.len,10))||u.len in a))throw new Error("Given an array length without a matching type");u=ctParseType(u.type)}if(!(u.type in t))throw new Error("type not found or typdefed: "+u.type);if(n!==undefined)for(i=0;i<n.length;i++)if(!(n[i]in s[o[0]]))throw new Error("Missing required field: "+n[i]);a[o[0]]=!0}}function CTypeParser(e){if(!e)throw new Error("missing required argument");if(!("endian"in e))throw new Error("missing required endian value");if(e["endian"]!="big"&&e["endian"]!="little")throw new Error("Invalid endian type");if("char-type"in e&&e["char-type"]!="uint8"&&e["char-type"]!="int8")throw new Error("invalid option for char-type: "+e["char-type"]);this.endian=e.endian;this.types=ctGetBasicTypes();"char-type"in e&&e["char-type"]=="uint8"&&(this.types["char"]=this.types.uint8_t);"char-type"in e&&e["char-type"]=="int8"&&(this.types["char"]=this.types.int8_t)}function ctResolveArray(e,t){var n="",r=ctParseType(e);while(r.len!==undefined){if(isNaN(parseInt(r.len,10))){if(typeof t[r["len"]]!="number")throw new Error("cannot sawp in non-number for array value");n="["+t[r.len]+"]"+n}else n="["+r.len+"]"+n;r=ctParseType(r.type)}n=r.type+n;return n}function getValues(e){var t,n,r;n=[];for(t=0;t<e.length;t++){r=Object.keys(e[t])[0];mod_assert.ok("value"in e[t][r]);n.push(e[t][r].value)}return n}function toAbs64(e){if(e===undefined)throw new Error("missing required arg: value");if(!Array.isArray(e))throw new Error("value must be an array");if(e.length!=2)throw new Error("value must be an array of length 2");if(e[0]>=1048576)throw new Error("value would become approximated");return e[0]*Math.pow(2,32)+e[1]}function toApprox64(e){if(e===undefined)throw new Error("missing required arg: value");if(!Array.isArray(e))throw new Error("value must be an array");if(e.length!=2)throw new Error("value must be an array of length 2");return Math.pow(2,32)*e[0]+e[1]}function parseCTF(e,t){var n=new CTypeParser(t);mod_ctf.ctfParseJson(e,n);return n}var mod_ctf=require("./ctf.js"),mod_ctio=require("./ctio.js"),mod_assert=require("assert"),deftypes={uint8_t:{read:ctReadUint8,write:ctWriteUint8},uint16_t:{read:ctReadUint16,write:ctWriteUint16},uint32_t:{read:ctReadUint32,write:ctWriteUint32},uint64_t:{read:ctReadUint64,write:ctWriteUint64},int8_t:{read:ctReadSint8,write:ctWriteSint8},int16_t:{read:ctReadSint16,write:ctWriteSint16},int32_t:{read:ctReadSint32,write:ctWriteSint32},int64_t:{read:ctReadSint64,write:ctWriteSint64},"float":{read:ctReadFloat,write:ctWriteFloat},"double":{read:ctReadDouble,write:ctWriteDouble},"char":{read:ctReadChar,write:ctWriteChar},"char[]":{read:ctReadCharArray,write:ctWriteCharArray}};CTypeParser.prototype.setEndian=function(e){if(e!="big"&&e!="little")throw new Error("invalid endian type, must be big or little");this.endian=e};CTypeParser.prototype.getEndian=function(){return this.endian};CTypeParser.prototype.typedef=function(e,t){var n;if(e===undefined)throw new(Error("missing required typedef argument: name"));if(t===undefined)throw new(Error("missing required typedef argument: value"));if(typeof e!="string")throw new(Error("the name of a type must be a string"));n=ctParseType(e);if(n.len!==undefined)throw new Error("Cannot have an array in the typedef name");if(e in this.types)throw new Error("typedef name already present: "+e);if(!(typeof t=="string"||t instanceof Array))throw new Error("typedef value must either be a string or struct");if(typeof t=="string"){n=ctParseType(t);if(n.len!==undefined&&isNaN(parseInt(n.len,10)))throw new(Error("typedef value must use fixed size array when outside of a struct"));this.types[e]=t}else{ctCheckReq(t,this.types);this.types[e]=t}};CTypeParser.prototype.lstypes=function(){var e,t={};for(e in this.types){if(e in deftypes)continue;t[e]=this.types[e]}return t};CTypeParser.prototype.resolveTypedef=function(e,t,n,r,i){var s;mod_assert.ok(e in this.types);if(typeof this.types[e]=="string"){s=ctParseType(this.types[e]);if(t=="read")return this.readEntry(s,n,r);if(t=="write")return this.writeEntry(i,s,n,r);throw new Error("invalid dispatch type to resolveTypedef")}if(t=="read")return this.readStruct(this.types[e],n,r);if(t=="write")return this.writeStruct(i,this.types[e],n,r);throw new Error("invalid dispatch type to resolveTypedef")};CTypeParser.prototype.readEntry=function(e,t,n){var r,i;if(e.len!==undefined){i=parseInt(e.len,10);if(isNaN(i))throw new Error("somehow got a non-numeric length");e["type"]=="char"?r=this.types["char[]"].read(i,this.endian,t,n):r=this.readArray(e.type,i,t,n)}else e.type in deftypes?r=this.types[e.type].read(this.endian,t,n):r=this.resolveTypedef(e.type,"read",t,n);return r};CTypeParser.prototype.readArray=function(e,t,n,r){var i,s,o,u=r,a=new Array(t);o=ctParseType(e);for(i=0;i<t;i++){s=this.readEntry(o,n,r);r+=s.size;a[i]=s.value}return{value:a,size:r-u}};CTypeParser.prototype.readStruct=function(e,t,n){var r,i,s,o,u,a=n,f={};for(i=0;i<e.length;i++){u=Object.keys(e[i])[0];o=e[i][u];s=ctParseType(ctResolveArray(o.type,f));"offset"in o&&(n=a+o.offset);r=this.readEntry(s,t,n);n+=r.size;f[u]=r.value}return{value:f,size:n-a}};CTypeParser.prototype.readData=function(e,t,n){if(e===undefined)throw new Error("missing definition for what we should beparsing");if(t===undefined)throw new Error("missing buffer for what we should be parsing");if(n===undefined)throw new Error("missing offset for what we should be parsing");ctCheckReq(e,this.types);return this.readStruct(e,t,n).value};CTypeParser.prototype.writeArray=function(e,t,n,r,i){var s,o,u=i;if(e instanceof Array){if(e.length!=n)throw new Error("asked to write array of length "+n+" but that does not match value length: "+e.length);o=ctParseType(t);for(s=0;s<n;s++)i+=this.writeEntry(e[s],o,r,i);return i-u}throw new Error("asked to write an array, but value is not an array")};CTypeParser.prototype.writeEntry=function(e,t,n,r){var i,s;if(t.len!==undefined){i=parseInt(t.len,10);if(isNaN(i))throw new Error("somehow got a non-numeric length");t["type"]=="char"?s=this.types["char[]"].write(e,i,this.endian,n,r):s=this.writeArray(e,t.type,i,n,r)}else t.type in deftypes?s=this.types[t.type].write(e,this.endian,n,r):s=this.resolveTypedef(t.type,"write",n,r,e);return s};CTypeParser.prototype.writeStruct=function(e,t,n,r){var i,s,o,u,a=r,f={};for(i=0;i<t.length;i++){u=Object.keys(t[i])[0];s=t[i][u];o=ctParseType(ctResolveArray(s.type,f));"offset"in s&&(r=a+s.offset);r+=this.writeEntry(e[i],o,n,r);f[u]=e[i]}return r};CTypeParser.prototype.writeData=function(e,t,n,r){var i;if(e===undefined)throw new Error("missing definition for what we should beparsing");if(t===undefined)throw new Error("missing buffer for what we should be parsing");if(n===undefined)throw new Error("missing offset for what we should be parsing");i=r!=null&&r!=undefined;if(i){if(!Array.isArray(r))throw new Error("missing values for writing");ctCheckReq(e,this.types)}else ctCheckReq(e,this.types,["value"]);this.writeStruct(i?r:getValues(e),e,t,n)};exports.Parser=CTypeParser;exports.toAbs64=toAbs64;exports.toApprox64=toApprox64;exports.parseCTF=parseCTF;exports.ruint8=mod_ctio.ruint8;exports.ruint16=mod_ctio.ruint16;exports.ruint32=mod_ctio.ruint32;exports.ruint64=mod_ctio.ruint64;exports.wuint8=mod_ctio.wuint8;exports.wuint16=mod_ctio.wuint16;exports.wuint32=mod_ctio.wuint32;exports.wuint64=mod_ctio.wuint64;exports.rsint8=mod_ctio.rsint8;exports.rsint16=mod_ctio.rsint16;exports.rsint32=mod_ctio.rsint32;exports.rsint64=mod_ctio.rsint64;exports.wsint8=mod_ctio.wsint8;exports.wsint16=mod_ctio.wsint16;exports.wsint32=mod_ctio.wsint32;exports.wsint64=mod_ctio.wsint64;exports.rfloat=mod_ctio.rfloat;exports.rdouble=mod_ctio.rdouble;exports.wfloat=mod_ctio.wfloat;exports.wdouble=mod_ctio.wdouble;