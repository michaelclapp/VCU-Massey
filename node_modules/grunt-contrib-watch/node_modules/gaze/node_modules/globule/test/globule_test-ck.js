"use strict";var path=require("path"),globule=require("../lib/globule.js");exports.match={"empty set":function(e){e.expect(6);e.deepEqual(globule.match(null,"foo.js"),[],"should return empty set.");e.deepEqual(globule.match("*.js",null),[],"should return empty set.");e.deepEqual(globule.match([],"foo.js"),[],"should return empty set.");e.deepEqual(globule.match("*.js",[]),[],"should return empty set.");e.deepEqual(globule.match(null,["foo.js"]),[],"should return empty set.");e.deepEqual(globule.match(["*.js"],null),[],"should return empty set.");e.done()},"basic matching":function(e){e.expect(6);e.deepEqual(globule.match("*.js","foo.js"),["foo.js"],"should match correctly.");e.deepEqual(globule.match("*.js",["foo.js"]),["foo.js"],"should match correctly.");e.deepEqual(globule.match("*.js",["foo.js","bar.css"]),["foo.js"],"should match correctly.");e.deepEqual(globule.match(["*.js","*.css"],"foo.js"),["foo.js"],"should match correctly.");e.deepEqual(globule.match(["*.js","*.css"],["foo.js"]),["foo.js"],"should match correctly.");e.deepEqual(globule.match(["*.js","*.css"],["foo.js","bar.css"]),["foo.js","bar.css"],"should match correctly.");e.done()},"no matches":function(e){e.expect(2);e.deepEqual(globule.match("*.js","foo.css"),[],"should fail to match.");e.deepEqual(globule.match("*.js",["foo.css","bar.css"]),[],"should fail to match.");e.done()},unique:function(e){e.expect(2);e.deepEqual(globule.match("*.js",["foo.js","foo.js"]),["foo.js"],"should return a uniqued set.");e.deepEqual(globule.match(["*.js","*.*"],["foo.js","foo.js"]),["foo.js"],"should return a uniqued set.");e.done()},flatten:function(e){e.expect(1);e.deepEqual(globule.match([["*.js","*.css"],["*.*","*.js"]],["foo.js","bar.css"]),["foo.js","bar.css"],"should process nested pattern arrays correctly.");e.done()},exclusion:function(e){e.expect(5);e.deepEqual(globule.match(["!*.js"],["foo.js","bar.js"]),[],"solitary exclusion should match nothing");e.deepEqual(globule.match(["*.js","!*.js"],["foo.js","bar.js"]),[],"exclusion should cancel match");e.deepEqual(globule.match(["*.js","!f*.js"],["foo.js","bar.js","baz.js"]),["bar.js","baz.js"],"partial exclusion should partially cancel match");e.deepEqual(globule.match(["*.js","!*.js","b*.js"],["foo.js","bar.js","baz.js"]),["bar.js","baz.js"],"inclusion / exclusion order matters");e.deepEqual(globule.match(["*.js","!f*.js","*.js"],["foo.js","bar.js","baz.js"]),["bar.js","baz.js","foo.js"],"inclusion / exclusion order matters");e.done()},"options.matchBase":function(e){e.expect(2);e.deepEqual(globule.match("*.js",["foo.js","bar","baz/xyz.js"],{matchBase:!0}),["foo.js","baz/xyz.js"],"should matchBase (minimatch) when specified.");e.deepEqual(globule.match("*.js",["foo.js","bar","baz/xyz.js"]),["foo.js"],"should not matchBase (minimatch) by default.");e.done()}};exports.isMatch={"basic matching":function(e){e.expect(6);e.ok(globule.isMatch("*.js","foo.js"),"should match correctly.");e.ok(globule.isMatch("*.js",["foo.js"]),"should match correctly.");e.ok(globule.isMatch("*.js",["foo.js","bar.css"]),"should match correctly.");e.ok(globule.isMatch(["*.js","*.css"],"foo.js"),"should match correctly.");e.ok(globule.isMatch(["*.js","*.css"],["foo.js"]),"should match correctly.");e.ok(globule.isMatch(["*.js","*.css"],["foo.js","bar.css"]),"should match correctly.");e.done()},"no matches":function(e){e.expect(6);e.ok(!globule.isMatch("*.js","foo.css"),"should fail to match.");e.ok(!globule.isMatch("*.js",["foo.css","bar.css"]),"should fail to match.");e.ok(!globule.isMatch(null,"foo.css"),"should fail to match.");e.ok(!globule.isMatch("*.js",null),"should fail to match.");e.ok(!globule.isMatch([],"foo.css"),"should fail to match.");e.ok(!globule.isMatch("*.js",[]),"should fail to match.");e.done()},"options.matchBase":function(e){e.expect(2);e.ok(globule.isMatch("*.js",["baz/xyz.js"],{matchBase:!0}),"should matchBase (minimatch) when specified.");e.ok(!globule.isMatch("*.js",["baz/xyz.js"]),"should not matchBase (minimatch) by default.");e.done()}};exports.find={setUp:function(e){this.cwd=process.cwd();process.chdir("test/fixtures/expand");e()},tearDown:function(e){process.chdir(this.cwd);e()},"basic matching":function(e){e.expect(5);e.deepEqual(globule.find("**/*.js"),["js/bar.js","js/foo.js"],"single pattern argument should match.");e.deepEqual(globule.find("**/*.js","**/*.css"),["js/bar.js","js/foo.js","css/baz.css","css/qux.css"],"multiple pattern arguments should match.");e.deepEqual(globule.find(["**/*.js","**/*.css"]),["js/bar.js","js/foo.js","css/baz.css","css/qux.css"],"array of patterns should match.");e.deepEqual(globule.find([["**/*.js"],[["**/*.css","js/*.js"]]]),["js/bar.js","js/foo.js","css/baz.css","css/qux.css"],"array of arrays of patterns should be flattened.");e.deepEqual(globule.find("*.xyz"),[],"bad pattern should fail to match.");e.done()},unique:function(e){e.expect(4);e.deepEqual(globule.find("**/*.js","js/*.js"),["js/bar.js","js/foo.js"],"file list should be uniqed.");e.deepEqual(globule.find("**/*.js","**/*.css","js/*.js"),["js/bar.js","js/foo.js","css/baz.css","css/qux.css"],"file list should be uniqed.");e.deepEqual(globule.find("js","js/"),["js","js/"],"mixed non-ending-/ and ending-/ dirs will not be uniqed by default.");e.deepEqual(globule.find("js","js/",{mark:!0}),["js/"],'mixed non-ending-/ and ending-/ dirs will be uniqed when "mark" is specified.');e.done()},"file order":function(e){e.expect(5);var t=globule.find("**/*.{js,css}"),n=["css/baz.css","css/qux.css","js/bar.js","js/foo.js"];e.deepEqual(t,n,"should select 4 files in this order, by default.");t=globule.find("js/foo.js","js/bar.js","**/*.{js,css}");n=["js/foo.js","js/bar.js","css/baz.css","css/qux.css"];e.deepEqual(t,n,"specifically-specified-up-front file order should be maintained.");t=globule.find("js/bar.js","js/foo.js","**/*.{js,css}");n=["js/bar.js","js/foo.js","css/baz.css","css/qux.css"];e.deepEqual(t,n,"specifically-specified-up-front file order should be maintained.");t=globule.find("**/*.{js,css}","!css/qux.css","css/qux.css");n=["css/baz.css","js/bar.js","js/foo.js","css/qux.css"];e.deepEqual(t,n,"if a file is excluded and then re-added, it should be added at the end.");t=globule.find("js/foo.js","**/*.{js,css}","!css/qux.css","css/qux.css");n=["js/foo.js","css/baz.css","js/bar.js","css/qux.css"];e.deepEqual(t,n,"should be able to combine specified-up-front and excluded/added-at-end.");e.done()},exclusion:function(e){e.expect(8);e.deepEqual(globule.find(["!js/*.js"]),[],"solitary exclusion should match nothing");e.deepEqual(globule.find(["js/bar.js","!js/bar.js"]),[],"exclusion should negate match");e.deepEqual(globule.find(["**/*.js","!js/foo.js"]),["js/bar.js"],"should omit single file from matched set");e.deepEqual(globule.find(["!js/foo.js","**/*.js"]),["js/bar.js","js/foo.js"],"inclusion / exclusion order matters");e.deepEqual(globule.find(["**/*.js","**/*.css","!js/bar.js","!css/baz.css"]),["js/foo.js","css/qux.css"],"multiple exclusions should be removed from the set");e.deepEqual(globule.find(["**/*.js","**/*.css","!**/*.css"]),["js/bar.js","js/foo.js"],"excluded wildcards should be removed from the matched set");e.deepEqual(globule.find(["js/bar.js","js/foo.js","css/baz.css","css/qux.css","!**/b*.*"]),["js/foo.js","css/qux.css"],"different pattern for exclusion should still work");e.deepEqual(globule.find(["js/bar.js","!**/b*.*","js/foo.js","css/baz.css","css/qux.css"]),["js/foo.js","css/baz.css","css/qux.css"],"inclusion / exclusion order matters");e.done()},"options.mark":function(e){e.expect(4);e.deepEqual(globule.find("**d*/**"),["deep","deep/deep.txt","deep/deeper","deep/deeper/deeper.txt","deep/deeper/deepest","deep/deeper/deepest/deepest.txt"],"should match files and directories.");e.deepEqual(globule.find("**d*/**/"),["deep/","deep/deeper/","deep/deeper/deepest/"],"trailing / in pattern should match directories only, matches end in /.");e.deepEqual(globule.find("**d*/**",{mark:!0}),["deep/","deep/deep.txt","deep/deeper/","deep/deeper/deeper.txt","deep/deeper/deepest/","deep/deeper/deepest/deepest.txt"],'the minimatch "mark" option ensures directories end in /.');e.deepEqual(globule.find("**d*/**/",{mark:!0}),["deep/","deep/deeper/","deep/deeper/deepest/"],'the minimatch "mark" option should not remove trailing / from matched paths.');e.done()},"options.filter":function(e){e.expect(5);e.deepEqual(globule.find("**d*/**",{filter:"isFile"}),["deep/deep.txt","deep/deeper/deeper.txt","deep/deeper/deepest/deepest.txt"],"should match files only.");e.deepEqual(globule.find("**d*/**",{filter:"isDirectory"}),["deep","deep/deeper","deep/deeper/deepest"],"should match directories only.");e.deepEqual(globule.find("**",{arbitraryProp:/deepest/,filter:function(e,t){return t.arbitraryProp.test(e)}}),["deep/deeper/deepest","deep/deeper/deepest/deepest.txt"],"should filter arbitrarily.");e.deepEqual(globule.find("js","css",{filter:"isFile"}),[],"should fail to match.");e.deepEqual(globule.find("**/*.js",{filter:"isDirectory"}),[],"should fail to match.");e.done()},"options.matchBase":function(e){e.expect(3);e.deepEqual(globule.find("*.js"),[],"should not matchBase (minimatch) by default.");e.deepEqual(globule.find("*.js",{matchBase:!0}),["js/bar.js","js/foo.js"],"matchBase option should be passed through to minimatch.");e.deepEqual(globule.find("*.js","*.css",{matchBase:!0}),["js/bar.js","js/foo.js","css/baz.css","css/qux.css"],"matchBase option should be passed through to minimatch.");e.done()},"options.srcBase":function(e){e.expect(5);e.deepEqual(globule.find(["**/deep*.txt"],{srcBase:"deep"}),["deep.txt","deeper/deeper.txt","deeper/deepest/deepest.txt"],"should find paths matching pattern relative to srcBase.");e.deepEqual(globule.find(["**/deep*.txt"],{cwd:"deep"}),["deep.txt","deeper/deeper.txt","deeper/deepest/deepest.txt"],"cwd and srcBase should do the same thing.");e.deepEqual(globule.find(["**/deep*"],{srcBase:"deep",filter:"isFile"}),["deep.txt","deeper/deeper.txt","deeper/deepest/deepest.txt"],"srcBase should not prevent filtering.");e.deepEqual(globule.find(["**/deep*"],{srcBase:"deep",filter:"isDirectory"}),["deeper","deeper/deepest"],"srcBase should not prevent filtering.");e.deepEqual(globule.find(["**/deep*.txt","!**/deeper**"],{srcBase:"deep"}),["deep.txt","deeper/deepest/deepest.txt"],"srcBase should not prevent exclusions.");e.done()},"options.prefixBase":function(e){e.expect(2);e.deepEqual(globule.find(["**/deep*.txt"],{srcBase:"deep",prefixBase:!1}),["deep.txt","deeper/deeper.txt","deeper/deepest/deepest.txt"],"should not prefix srcBase to returned paths.");e.deepEqual(globule.find(["**/deep*.txt"],{srcBase:"deep",prefixBase:!0}),["deep/deep.txt","deep/deeper/deeper.txt","deep/deeper/deepest/deepest.txt"],"should prefix srcBase to returned paths.");e.done()},"options.nonull":function(e){e.expect(3);e.deepEqual(globule.find(["*omg*"],{nonull:!0}),["*omg*"],"non-matching patterns should be returned in result set.");e.deepEqual(globule.find(["js/a*","js/b*","js/c*"],{nonull:!0}),["js/a*","js/bar.js","js/c*"],"non-matching patterns should be returned in result set.");e.deepEqual(globule.find(["js/foo.js","js/bar.js","js/nonexistent.js"],{nonull:!0}),["js/foo.js","js/bar.js","js/nonexistent.js"],"non-matching filenames should be returned in result set.");e.done()}};exports.mapping={"basic mapping":function(e){e.expect(1);var t=globule.mapping(["a.txt","b.txt","c.txt"]),n=[{dest:"a.txt",src:["a.txt"]},{dest:"b.txt",src:["b.txt"]},{dest:"c.txt",src:["c.txt"]}];e.deepEqual(t,n,"default options should create same-to-same src-dest mappings.");e.done()},"options.srcBase":function(e){e.expect(2);var t,n;t=globule.mapping(["a.txt","bar/b.txt","bar/baz/c.txt"],{srcBase:"foo"});n=[{dest:"a.txt",src:["foo/a.txt"]},{dest:"bar/b.txt",src:["foo/bar/b.txt"]},{dest:"bar/baz/c.txt",src:["foo/bar/baz/c.txt"]}];e.deepEqual(t,n,"srcBase should be prefixed to src paths (no trailing /).");t=globule.mapping(["a.txt","bar/b.txt","bar/baz/c.txt"],{srcBase:"foo/"});e.deepEqual(t,n,"srcBase should be prefixed to src paths (trailing /).");e.done()},"options.destBase":function(e){e.expect(2);var t,n;t=globule.mapping(["a.txt","bar/b.txt","bar/baz/c.txt"],{destBase:"dest"});n=[{dest:"dest/a.txt",src:["a.txt"]},{dest:"dest/bar/b.txt",src:["bar/b.txt"]},{dest:"dest/bar/baz/c.txt",src:["bar/baz/c.txt"]}];e.deepEqual(t,n,"destBase should be prefixed to dest paths (no trailing /).");t=globule.mapping(["a.txt","bar/b.txt","bar/baz/c.txt"],{destBase:"dest/"});e.deepEqual(t,n,"destBase should be prefixed to dest paths (trailing /).");e.done()},"options.flatten":function(e){e.expect(1);var t,n;t=globule.mapping(["a.txt","bar/b.txt","bar/baz/c.txt"],{flatten:!0});n=[{dest:"a.txt",src:["a.txt"]},{dest:"b.txt",src:["bar/b.txt"]},{dest:"c.txt",src:["bar/baz/c.txt"]}];e.deepEqual(t,n,"flatten should remove all src path parts from dest.");e.done()},"options.flatten + options.destBase":function(e){e.expect(1);var t,n;t=globule.mapping(["a.txt","bar/b.txt","bar/baz/c.txt"],{destBase:"dest",flatten:!0});n=[{dest:"dest/a.txt",src:["a.txt"]},{dest:"dest/b.txt",src:["bar/b.txt"]},{dest:"dest/c.txt",src:["bar/baz/c.txt"]}];e.deepEqual(t,n,"flatten and destBase should work together.");e.done()},"options.ext":function(e){e.expect(1);var t,n;t=globule.mapping(["x/a.js","x.y/b.min.js","x.y/z.z/c"],{ext:".foo"});n=[{dest:"x/a.foo",src:["x/a.js"]},{dest:"x.y/b.foo",src:["x.y/b.min.js"]},{dest:"x.y/z.z/c.foo",src:["x.y/z.z/c"]}];e.deepEqual(t,n,"by default, ext should replace everything after the first dot in the filename.");e.done()},"options.extDot":function(e){e.expect(2);var t,n;t=globule.mapping(["x/a.js","x.y/b.bbb.min.js","x.y/z.z/c"],{ext:".foo",extDot:"first"});n=[{dest:"x/a.foo",src:["x/a.js"]},{dest:"x.y/b.foo",src:["x.y/b.bbb.min.js"]},{dest:"x.y/z.z/c.foo",src:["x.y/z.z/c"]}];e.deepEqual(t,n,'extDot of "first" should replace everything after the first dot in the filename.');t=globule.mapping(["x/a.js","x.y/b.bbb.min.js","x.y/z.z/c"],{ext:".foo",extDot:"last"});n=[{dest:"x/a.foo",src:["x/a.js"]},{dest:"x.y/b.bbb.min.foo",src:["x.y/b.bbb.min.js"]},{dest:"x.y/z.z/c.foo",src:["x.y/z.z/c"]}];e.deepEqual(t,n,'extDot of "last" should replace everything after the last dot in the filename.');e.done()},"options.rename":function(e){e.expect(1);var t,n;t=globule.mapping(["a.txt","bar/b.txt","bar/baz/c.txt"],{arbitraryProp:"FOO",rename:function(e,t){return path.join(t.arbitraryProp,e.toUpperCase())}});n=[{dest:"FOO/A.TXT",src:["a.txt"]},{dest:"FOO/BAR/B.TXT",src:["bar/b.txt"]},{dest:"FOO/BAR/BAZ/C.TXT",src:["bar/baz/c.txt"]}];e.deepEqual(t,n,"allow arbitrary renaming of files.");e.done()}};exports.findMapping={setUp:function(e){this.cwd=process.cwd();process.chdir("test/fixtures");e()},tearDown:function(e){process.chdir(this.cwd);e()},"basic matching":function(e){e.expect(2);var t=globule.findMapping(["expand/**/*.txt"]),n=[{dest:"expand/deep/deep.txt",src:["expand/deep/deep.txt"]},{dest:"expand/deep/deeper/deeper.txt",src:["expand/deep/deeper/deeper.txt"]},{dest:"expand/deep/deeper/deepest/deepest.txt",src:["expand/deep/deeper/deepest/deepest.txt"]}];e.deepEqual(t,n,"default options");n=globule.mapping(globule.find(["expand/**/*.txt"]));e.deepEqual(t,n,"this is what it's doing under the hood, anwyays.");e.done()},"options.srcBase":function(e){e.expect(1);var t=globule.findMapping(["**/*.txt"],{destBase:"dest",srcBase:"expand/deep"}),n=[{dest:"dest/deep.txt",src:["expand/deep/deep.txt"]},{dest:"dest/deeper/deeper.txt",src:["expand/deep/deeper/deeper.txt"]},{dest:"dest/deeper/deepest/deepest.txt",src:["expand/deep/deeper/deepest/deepest.txt"]}];e.deepEqual(t,n,"srcBase should be stripped from front of destPath, pre-destBase+destPath join");e.done()}};